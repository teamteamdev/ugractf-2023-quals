# Элементарно: Write-up

Таск состоит из одного скрипта, проверяющего введенный пользователем флаг на корректность:

```python
import base64
import hashlib
import sys


def abort():
    print("Wrong flag!")
    sys.exit(1)


flag = input()

if len(flag) != 29:
    abort()
if flag[17] != 'p':
    abort()
if flag[:5] != 'ugra_':
    abort()
if flag[9:3:-2] != 'nta':
    abort()
if flag[-2:-15:-3].encode().hex() != '39676f6767':
    abort()
if int.from_bytes(flag[6:18:2].encode(), "little") != 104927802781555:
    abort()
if sum(ord(x) * 1000 ** i for i, x in enumerate(flag[19:-4])) != 103111101111057120:
    abort()
if base64.b64encode(flag[-4:].encode()) != b'bDU5bQ==':
    abort()
if hashlib.sha256(flag.encode()).hexdigest() != '1e5eddb6b5212489e4782b7c01ba5975237fe0ee4b58ed4f6ecade260f5b4856':
    abort()

print("OK!")
```

Нужно написать keygen.

Первое, что бросается в глаза — символов во флаге 29. Дальше идет череда проверок некоторых символов и подстрок, каждая из которых дает нам информацию об очередном куске флага.

Будем читать код сверху вниз и отмечать, что нам известно о флаге.

- 17-й символ в 0-нумерации — `p`: `?????????????????p???????????`
- Строка начинается с `ugra_`: `ugra_????????????p???????????`
- С 9-го по 3-й символ невключительно, идя с шагом −2, выписывается строка `nta`; то есть 9-й символ равен `n`, 7-й — `t`, 5-й — `a`: `ugra_a?t?n???????p???????????`
- С −2-го (с конца; то есть 29−2 = 27-го) по −15-й (то есть 29−15 = 14-й) символ невключительно, идя с шагом −3, выписывается строка, которая в hex выражается как `39676f6767`; раскодировав hex, получаем, что это `9gogg`: `ugra_a?t?n?????g?pg??o??g??9?`
- С 6-го по 18-й символ невключительно, идя с шагом 2, выписывается строка длины, очевидно, 6, которая, если ее проинтерпретировать как число, равна `104927802781555`. Кодируя `104927802781555` в little-endian в строку байтов (например, в Python: `(104927802781555).to_bytes(6, "little")`), получаем `soihn_`: `ugra_astoni?h?ng_pg??o??g??9?`
- С 19-го по −4-й (то есть 29-4 = 25-й) символ невключительно, если записать ASCII-коды символов в число, по сути, в 1000-ричной системе счисления, получится 103111101111057120. То есть 19-й символ имеет ASCII-код 120 (`x`), 20-й — 57 (`9`), и т.д., вплоть до 24-го, имеющего код 103 (`g`): `ugra_astoni?h?ng_pgx9oeog??9?`
- Последние 4 символа кодируются в base64 как `bDU5bQ==`, то есть равны `l59m`: `ugra_astoni?h?ng_pgx9oeogl59m`

Это дает почти весь флаг, кроме двух символов. Их можно либо подобрать исходя из знаний английского языка — угадывается слово `astonishing` — либо перебрав эти два символа в поисках нужного хеша:

```python
import hashlib

for a in range(256):
    for b in range(256):
        flag = "ugra_astoni" + chr(a) + "h" + chr(b) + "ng_pgx9oeogl59m"
        if hashlib.sha256(flag.encode()).hexdigest() == "1e5eddb6b5212489e4782b7c01ba5975237fe0ee4b58ed4f6ecade260f5b4856":
            print(flag)
```

Флаг: **ugra_astonishing_pgx9oeogl59m**
