# Мультфильмы: Write-up

Текстовый файл на два мегабайта — это страшно. gedit, например, такого издевательства не выдерживает. Emacs тоже, хотя через минуту он файл все-таки открывает. С Vim ситуация получше. Пользователям Windows повезло больше — Notepad, как ни странно, с большими файлами работать умеет.

Так или иначе, после открытия файла становится ясно, что по большей части он действительно текстовый: есть много строк (по-видимому, команд) вида `[2;6H`, пробелы, несколько закрашенных квадратов из Unicode, и только один специальный символ, появляющийся перед командами. Чтобы понять, что это за символ, можно, например, воспользоваться каким-нибудь hex-редактором или hex-просмотрщиком.

Например, если вы пользуетесь Linux, можно воспользоваться командой

```shell
$ xxd /path/to/movie.txt | head
```

```
00000000: 1b5b 323b 3534 4820 1b5b 323b 3339 4820  .[2;54H .[2;39H 
00000010: 1b5b 323b 3431 4820 1b5b 323b 3634 4820  .[2;41H .[2;64H 
00000020: 1b5b 323b 3134 4820 1b5b 323b 3537 4820  .[2;14H .[2;57H 
00000030: 1b5b 323b 3138 4820 1b5b 323b 3630 4820  .[2;18H .[2;60H 
00000040: 1b5b 323b 3330 4820 1b5b 323b 3332 4820  .[2;30H .[2;32H 
00000050: 1b5b 323b 3232 4820 1b5b 323b 3136 4820  .[2;22H .[2;16H 
00000060: 1b5b 323b 3436 4820 1b5b 323b 3536 4820  .[2;46H .[2;56H 
00000070: 1b5b 323b 3148 201b 5b32 3b34 3548 201b  .[2;1H .[2;45H .
00000080: 5b32 3b33 4820 1b5b 323b 3648 201b 5b32  [2;3H .[2;6H .[2
00000090: 3b33 3148 201b 5b32 3b32 3048 201b 5b32  ;31H .[2;20H .[2
```

И посмотреть, какое число соответствует специальному символу, обозначенному в правой колонке `.`. Еще один универсальный прием — воспользоваться автоформатированием Python:

```python
>>> open("/path/to/movie.txt", "rb").read(16)
b'\x1b[2;54H \x1b[2;39H '
```

Так или иначе, логично посмотреть, что означает в ASCII символ с кодом 1b. После пары минут чтения Википедии можно наткнуться на раздел [ASCII#Escape](https://en.wikipedia.org/wiki/ASCII#Escape):

> In modern usage, an ESC sent *to* the terminal usually indicates the start of a command sequence usually in the form of a so-called "[ANSI escape code](https://en.wikipedia.org/wiki/ANSI_escape_code)" (or, more properly, a "[Control Sequence Introducer](https://en.wikipedia.org/wiki/Control_Sequence_Introducer)") from ECMA-48 (1972) and its successors, beginning with ESC followed by a "[" (left-bracket) character.

В нашем файле после 1b всегда встречается символ [, так что, вероятнее всего, это и есть CSI.

Особо упорные могут проследовать на страницу [ANSI escape code#CSI sequences](https://en.wikipedia.org/wiki/ANSI_escape_code#CSIsection), убедиться, что `\x1b[<n>;<m>H` означает изменение позиции курсора, распарсить файл руками и посмотреть, что в итоге будет выведено на терминале.

Ничего.

Но какие-то непробельные символы из Unicode же были? Куда они делись? По-видимому, поверх них что-то было переписано. Это подсказывает и название таска. Поэтому разумно посмотреть на состояние терминала не после отрисовки всего файла, а, например, на его середине. Тогда будет заметно, что ASCII art'ом на экране нарисована часть флага. Подбирая константы, то есть моменты, в которые выводится состояние экрана, можно собрать все куски флага воедино.

Менее пылкие могут осознать, что раз CSI — коды для терминалов, то UNIX'овые эмуляторы терминалов вроде Linux vt, xterm, Gnome Terminal, uxvt и т.п. также должны их понимать, и достаточно вывести файл в терминал через `cat`:

```shell
$ cat /path/to/movie.txt
```

Если вы используете достаточно новый Windows, то встроенная консоль (conhost) и Windows Terminal также поддерживают CSI, и можно использовать:

```shell
> type \path\to\movie.txt
```

Если вы используете старый Windows, можно использовать, например, ConEmu.

Так или иначе, вас будет преследовать одна проблема — текст («мультфильм») выводится слишком быстро. Это можно решить, воспользовавшись какой-нибудь утилитой для замедления вывода. Например, StackOverflow [подсказывает](https://superuser.com/questions/239893/how-to-rate-limit-a-pipe-under-linux), что это можно сделать так:

```shell
$ pv -q -L 3k /path/to/movie.txt
```

Впрочем, `3k` — слишком медленно, так что скорость можно поднять до `100k`. Чит: для приостановки вывода можно использовать `^Z`, для продолжения — `fg`.

В случае с Windows возникает еще одна проблема — кодировка. Windows часто использует по умолчанию устаревшие кодировки вместо UTF-8, поэтому приходится убеждать его использовать именно ее. В `cmd.exe` это делается так:

```shell
> chcp 65001
> type \path\to\movie.txt
```

В случае PowerShell:

```shell
> Get-Content -Encoding UTF8 \path\to\movie.txt
```

В Windows замедлить вывод в терминал, не прибегая к самописным скриптам, сложно, поэтому, если вам не придет в голову идея запустить cmd в медленном терминале, например встроенном (т.е. conhost вместо Windows Terminal), и быстро нажимать PrtScr, может быть разумнее поставить [WSL](https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux) и воспользоваться решением для Linux, благо WSL будет полезен и для многих других вещей.

Флаг: **ugra_weve_got_terminals_pdwetksbjbrf**
