# Советские вступительные в ясельный класс: Write-up

## Как в реальности работает рекурсия
Память для программы делится на кучу и стек. В куче хранятся большие объекты с
долгим сроком жизни, а в стеке то, что нужно здесь и сейчас.

Функции имеют локальные переменные, которые надо где-то хранить. И если одна
функция вызывает другую функцию, то нужно знать куда возвращаться — то бишь
адрес возврата. Для всего этого используется стек, а точнее абстрация фрейма —
данные, необходимые для работы какой-то функции. При вызове функции из текущей
создается новый фрейм, а когда функция завершается, фрейм удаляется.

Обычно для доступа к локальным переменным со стека используется прямая адресация
— мы можем вычислить адрес переменной и обращаться туда. В нашем же случае у
нас есть доступ только к верхнему элементу со стека.

Классический подход состоит в использовании адресов возврата для рекурсии. Такое
решение представлено в альтернативном райтапе ниже. Далее же будет
решение, которое опирается на то, что у нас только одна точка возврата в функцию
из рекурсивного вызова.

## Решение задачи

Сначала напишем функцию на каком-нибудь человеческом языке:
```python
def f(n):
    if n == 1:
        return 1
    s = 0
    for i in range(1, n):
        if n % i == 0:
            s += f(i)
    return s + n
```

Функция, очевидно, рекурсивная. Но в теле есть только один вызов `f`,
следовательно, только одно место, куда можно вернуться.

Тогда наш код будет разбит на следующие блоки:
1. Инициализация
2. Функция
    1. Проверка на единицу
    2. Инициализация цикла
    3. Цикл
    4. Рекурсивный вызов
    5. Возврат из рекурсивного вызова
    6. Подсчет ответа
    7. Возвращение из функции
3. Завершение

При возвращении из функции у нас есть два пути: либо вернуться в пункт 5, либо
завершать программу. Чтобы решить, куда именно переходить, будем поддерживать
где-нибудь уровень рекурсии.

Вторым вопросом становится, как делать проверку на деление. У нас есть `div` и
`mul` для целых чисел, следовательно, мы можем сначала сделать `div`, потом
`mul`, и если итоговое число совпало с изначальным, значит, оно делится нацело.

И основной загвоздкой является сам рекурсивный вызов. Для цикла нам нужно три
вещи: счетчик цикла, аргумент функции и текущая сумма. Если мы спроектируем
функцию так, что она будет использовать только верхний элемент со стека, то
сможем безопасно сохранять эти значения там.

Чтобы не запутаться, будем делать пометки, в каком окружении ожидает
выполнения каждая из частей функции.

А теперь [сам код](./writeup/solution):
```
// d - stack size
// b - cycle iterator
// c - current sum
// a - argument

// инициализация
mov d 0

// a on stack
f:
add d 1
// проверка на единицу
pop a
sub a 1
je a "one"
add a 1

// инициализация цикла
push a
push 1
push 0
mov b 1

// цикл
// b, a on registers, abc on stack
loop:
// проверка нужен ли рекурсивный вызов
mov c a
div a b
mul a b
// кладем аргумент для рекурсивного вызова
push b
sub c a
// сам рекурсивный вызов
je c "f"
// забираем непонадобившийся аргумент
pop b
// достаем сумму в регистр, так как того ожидает skip
pop c
jmp "skip"

// abc<result> on stack
// возврат из рекурсивного вызова и увеличение суммы
return:
pop b
pop c
add c b

// c on registers, ab on stack
// увеличение счетчика и проверка условия выхода из него
skip:
pop b
add b 1
pop a
sub b a
je b "loopend"
// восстановление для следующей итерации
add b a
push a
push b
push c
jmp "loop"

// c, a on registers, empty stack
loopend:
add c a
// пишем результат
push c
jmp "fend"
one:
// пишем результат для единицы
push 1
fend:
sub d 1
// если был вложенный рекурсивный вызов, то возвращаем управление
jg d "return"
```

Решение с небольшими оптимизациями можно найти [тут](./writeup/solution.optimized).

Флаг: **ugra_ugra_ugra_ugrec_pdwetksbjbrf**

--------

Альтернативный райтап от [ivanq](https://github.com/imachug).

Реализуем для начала функцию на каком-нибудь человеческом языке:

```python
def f(n):
    if n == 1:
        return 1
    s = n
    for i in range(1, n):
        if n % i == 0:
            s += f(i)
            # (1)
    return s

result = f(n)
print(result)  # (2)
```

Сразу заметим, что отдельно обрабатывать случай `n == 1` отдельно не нужно, поскольку при `n == 1` цикл `for` сделает ноль итераций, и ответ получится нужный.

Этот код мы хотим перевести в ассемблер.

Без рекурсии здесь обойтись явно не получится: можно было бы использовать мемоизацию, но для этого нужно было бы обращаться к памяти по произвольному адресу, а у нас такой возможности нет.

Обычно рекурсия реализуется так:

- Есть инструкция `call "label"`, которая сохраняет на стек адрес следующей за ней инструкции (так называемый *адрес возврата*) и затем прыгает на метку `label`.
- И есть инструкция `ret`, которая достает со стека адрес инструкции и прыгает на него.

В нашем ассемблере, к сожалению, способа прыгнуть на произвольный адрес нет, поэтому, как реализовать `ret`, не очень понятно. Однако заметим, что у нас адресов возврата ровно два: это либо инструкция после `s += f(i)` (в псевдокоде `# (1)`), если функция была вызвана рекурсивно, либо `# (2)`, если это самый первый вызов. Поэтому на стеке можно хранить не честный адрес возврата, а, например, число 1, если нужно вернуться в `# (1)`, и 2, если нужно веруться в `# (2)`.

Кроме того, функциям нужны локальные переменные. В нашем случае это `n`, `s` и `i`. Эти переменные можно держать в регистрах `a`, `b`, `c` соответственно, сохранять на стек перед `call` и доставать их из стека сразу после. Это гарантирует, что рекурсивная функция может изменять свои переменные, не ломая состояние функции, которая ее вызвала.

Наконец, разберемся с *соглашением о вызове*. Функция `f` принимает и возвращает число; этот аргумент и возвращаемое значение нужно где-то хранить. Договоримся, что аргумент подается в регистре `a`, а результат возвращается в `d`. Это удобнее всего: аргумент `n` подается в том же регистре, где хранится `n`, а результат возвращается в регистр, который у нас ни для чего не используется.

Приступаем к написанию кода!

```
// Кладем n из ввода в регистр аргумента
pop a
// Адрес возврата и собственно вызов
push 2
jmp "f"
(2):
// Выводим ответ и завершаем выполнение
push d
jmp "exit"


f:
// Принимает n в a, возвращает s в b

// s = n, i = 1
mov b a
mov c 1

loop:
// Для начала проверим, не закончился ли цикл, то есть i == n, или, что то же самое, i - n == 0
sub c a
je c "loop_end"
add c a

// n % i == 0 эквивалентно тому, что (n / i) * i - n == 0
mov d a
div d c
mul d c
sub d a
je d "divides"
// Если прыжка не было, то n % i != 0, и нужно перейти на следующую итерацию цикла
add c 1
jmp "loop"

divides:
// Сохраняем локальные переменные. Сохранять d мы не будем, потому что там сейчас не интересующий нас мусор, все остальное сохраняем
push a
push b
push c
// Инициализируем аргумент n
mov a c
// Адрес возврата и собственно вызов
push 1
jmp "f"
(1):
// Возвращаем переменные
pop c
pop b
pop a
// s += f(i)
add b d
// Следующая итерация
add c 1
jmp "loop"

loop_end:
// Цикл закончился
// Кладем возвращаемое значение в регистр возврата
mov d b
// Смотрим, куда вернуться
pop a
// a == 1 <=> a - 1 == 0
sub a 1
je a "(1)"
// Если не (1), то точно (2)
jmp "(2)"


exit:
```

Флаг: **ugra_ugra_ugra_ugrec_pdwetksbjbrf**
