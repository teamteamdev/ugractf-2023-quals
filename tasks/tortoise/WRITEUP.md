# Скорость без границ: Write-up

У нас есть а) программа для расшифровки данных, б) данные, в) пароль. Внимание, вопрос: где подвох?

Если запустить `tortoisecrypt.py` и подать данные из условия, флаг начнет расшифровываться посимвольно. И если расшифровки первых символов пятнадцати дождаться еще можно, то дальше дело идет туго.

Но мы же готовы напрячь наш мозг, да?

## — Да

Придется оптимизировать алгоритм.

Алгоритм простой: есть инкрементальный хеш, для расшифровки каждого очередного байта хешируется повторение некоторой фиксированной строки, причем количество растет в геометрической прогрессии, и получившийся хеш используется в качестве XOR-ключа для очередного байта.

Идея простая: при фиксированном пароле по текущему состоянию хеша (12 байт) легко посчитать следующее состояние (также 12 байт), получающееся при добавлении к хешируемой строке пароля. По ходу алгоритма шифрования пароль прибавляется к хешу все больше и больше раз, то есть нужно много раз переходить от текущего хеша к следующему. Понятно, что поскольку хешей конечное число, однажды этот процесс зациклится. Можно экспериментально определить длину цикла и начиная с какого момента мы впервые входим в цикл, и по циклу больше одного раза не ходить. Например, если период повтора равен некоторому числу $k$, то вместо того, чтобы переходить к следующему состоянию $n$ раз, достаточно перейти $n~\\%~k$ раз (кроме случая, когда в цикл мы еще ни разу не попадали).

Если подсчитать, сколько времени мы так экономим, окажется, что число вычислений пропорционально количеству различных состояний и не зависит от количества повторов.

В данном случае состояний $256^{12} = 2^{96}$, что все равно слишком много. Но если внимательно проанализировать код хеша, окажется, что состояние хеша состоит из четырех 3-байтовых частей, вычисляющихся абсолютно независимо, которые склеиваются в одно состояние только в самом конце. Поэтому можно применить идею выше не для самого хеша, а для каждой из его частей. У каждой четвертинки состояний $256^{3} = 2^{24}$, что вполне возможно подсчитать на домашнем компьютере на том же Python.

Реализацию этого алгоритма с одной дополнительной оптимизацией (предподсчетом состояний и цикла) можно увидеть в файле [efficient_tortoisecrypt.py](efficient_tortoisecrypt.py).

## — Ну как сказать

Если не получается оптимизировать код асимптотически, можно попробовать переписать на другой язык и все аккуратно и посильнее оптимизировать. Понятно, что код будет работать все еще очень медленно, но, возможно, за время соревнования досчитается.

Код одной из команд, сделавших это, можно увидеть в файле [t.c](t.c):

```shell
$ clang -Ofast -o tf t.c -std=c2x -lcrypto
```

Код можно написать чуть более оптимально, а для параллельного подсчета четырех SHA256 использовать SIMD:

```shell
$ clang-15 -Ofast -flto -o tf optimized.c sha256.c -std=c2x -lcrypto -mavx -mavx2
```

Работает это, скажем откровенно, медленно, но за 10 часов досчитывается точно.

Флаг: **ugra_never_underestimate_predictability_qfx57xgkxsal**
